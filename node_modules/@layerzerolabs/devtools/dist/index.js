'use strict';

var assert = require('assert');
var bytes = require('@ethersproject/bytes');
var exponentialBackoff = require('exponential-backoff');
var ioDevtools = require('@layerzerolabs/io-devtools');
var jsYaml = require('js-yaml');
var lzDefinitions = require('@layerzerolabs/lz-definitions');
var zod = require('zod');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var assert__default = /*#__PURE__*/_interopDefault(assert);

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var isDeepEqual = (a, b) => {
  try {
    return assert.deepStrictEqual(a, b), true;
  } catch (e) {
    return false;
  }
};
var makeBytes32 = (address) => bytes.hexZeroPad(address || "0x0", 32);
var areBytes32Equal = (a, b) => BigInt(makeBytes32(a)) === BigInt(makeBytes32(b));
var isZero = (value) => value === "0x" || BigInt(value || 0) === BigInt(0);
var ignoreZero = (value) => isZero(value) ? void 0 : value != null ? value : void 0;
var compareBytes32Ascending = (a, b) => Number(BigInt(makeBytes32(a)) - BigInt(makeBytes32(b)));
var sequence = async (tasks) => {
  const collector = [];
  for (const task of tasks) {
    collector.push(await task());
  }
  return collector;
};
var parallel = async (tasks) => await Promise.all(tasks.map((task) => task()));
var mapError = async (task, toError) => {
  try {
    return await task();
  } catch (error) {
    throw toError(error);
  }
};
var tapError = async (task, onError) => {
  try {
    return await task();
  } catch (error) {
    try {
      await onError(error);
    } catch (e) {
    }
    throw error;
  }
};
var first = async (tasks) => {
  assert__default.default(tasks.length !== 0, `Must have at least one task for first()`);
  let lastError;
  for (const task of tasks) {
    try {
      return await task();
    } catch (error) {
      lastError = error;
    }
  }
  throw lastError;
};
var firstFactory = (...factories) => async (...input) => await first(factories.map((factory) => () => factory(...input)));
var createRetryFactory = (strategy = createSimpleRetryStrategy(3)) => (task) => async (...input) => {
  let currentInput = input;
  return exponentialBackoff.backOff(async () => task(...currentInput), {
    // We'll effectively disable the numOfAttempts for exponential backoff
    // since we want the behavior to be completely controlled by the strategy
    numOfAttempts: Number.POSITIVE_INFINITY,
    // The retry callback is called after an unsuccessful attemp
    //
    // It allows us to decide whether we want to keep trying or give up
    // (we can give up by returning false)
    //
    // We'll use this callback to allow the strategy to effectively make changes
    // to the input, thus allowing it to accommodate for things such as gas price increase
    // for transactions
    async retry(error, attempt) {
      const strategyOutput = await strategy(attempt, error, currentInput, input);
      if (typeof strategyOutput === "boolean") {
        return strategyOutput;
      }
      return currentInput = strategyOutput, true;
    }
  });
};
var createSimpleRetryStrategy = (numAttempts, wrappedStrategy) => {
  assert__default.default(numAttempts > 0, `Number of attempts for a strategy must be larger than 0`);
  return (attempt, error, previousInput, originalInput) => {
    if (attempt > numAttempts) {
      return false;
    }
    if (wrappedStrategy == null) {
      return true;
    }
    return wrappedStrategy(attempt, error, previousInput, originalInput);
  };
};
var createDefaultRetryHandler = (loggerName = "AsyncRetriable") => {
  const logger = ioDevtools.createModuleLogger(loggerName);
  return (attempt, numAttempts, error, target, method, args) => {
    logger.debug(`Attempt ${attempt}/${numAttempts}: ${method}() with arguments: ${ioDevtools.printJson(args)}: ${error}`);
  };
};
var AsyncRetriable = ({
  // We'll feature flag this functionality for the time being
  enabled = !!process.env.LZ_ENABLE_EXPERIMENTAL_RETRY,
  maxDelay,
  numAttempts = 3,
  onRetry = createDefaultRetryHandler()
} = {}) => {
  return function AsyncRetriableDecorator(target, propertyKey, descriptor) {
    if (!enabled) {
      return descriptor;
    }
    const originalMethod = descriptor.value;
    assert__default.default(
      typeof originalMethod === "function",
      `AsyncRetriable must be applied to an instance method, ${propertyKey} property looks more like ${typeof originalMethod}`
    );
    const handleRetry = (args) => (error, attempt) => {
      var _a4;
      return (_a4 = onRetry == null ? void 0 : onRetry(attempt, numAttempts, error, target, propertyKey, args)) != null ? _a4 : true;
    };
    const retriedMethod = function(...args) {
      return exponentialBackoff.backOff(() => originalMethod.apply(this, args), {
        // A typical problem in our case is 429 Too many requests
        // which would still happen if we didn't introduce a bit of randomness into the delay
        jitter: "full",
        maxDelay,
        numOfAttempts: numAttempts,
        retry: handleRetry(args)
      });
    };
    return descriptor.value = retriedMethod, descriptor;
  };
};

// src/common/strings.ts
var splitCommaSeparated = (value) => value.trim().split(/\s*,\s*/).filter(Boolean);
var serializeDockerComposeSpec = (spec) => jsYaml.dump(spec);
var arePointsEqual = (a, b) => a.address === b.address && a.eid === b.eid;
var areSameEndpoint = (a, b) => a.eid === b.eid;
var areVectorsEqual = (a, b) => arePointsEqual(a.from, b.from) && arePointsEqual(a.to, b.to);
var isVectorPossible = ({ from, to }) => lzDefinitions.endpointIdToStage(from.eid) === lzDefinitions.endpointIdToStage(to.eid);
var serializePoint = ({ address, eid }) => `${eid}|${address}`;
var serializeVector = ({ from, to }) => `${serializePoint(from)} \u2192 ${serializePoint(to)}`;
var vectorFromNodes = (a, b) => ({ from: a.point, to: b.point });
var withEid = (eid) => (value) => ({ ...value, eid });
var formatEid = (eid) => {
  var _a4;
  return (_a4 = lzDefinitions.EndpointId[eid]) != null ? _a4 : `Unknown EndpointId (${eid})`;
};
var formatOmniPoint = ({ eid, address }) => `[${address} @ ${formatEid(eid)}]`;
var formatOmniVector = ({ from, to }) => `${formatOmniPoint(from)} \u2192 ${formatOmniPoint(to)}`;

// src/common/map.ts
var _keys, _values, _entries, _a;
var AbstractMap = class {
  constructor(entries = []) {
    __privateAdd(this, _keys, /* @__PURE__ */ new Map());
    __privateAdd(this, _values, /* @__PURE__ */ new Map());
    __privateAdd(this, _entries, /* @__PURE__ */ new Map());
    __publicField(this, _a, "HashMap");
    for (const [key, value] of entries) {
      this.set(key, value);
    }
  }
  clear() {
    __privateGet(this, _keys).clear();
    __privateGet(this, _values).clear();
    __privateGet(this, _entries).clear();
  }
  delete(key) {
    const serialized = this.hash(key);
    return __privateGet(this, _keys).delete(serialized), __privateGet(this, _values).delete(serialized), __privateGet(this, _entries).delete(serialized);
  }
  forEach(callbackfn, thisArg) {
    for (const [_, [key, value]] of __privateGet(this, _entries)) {
      callbackfn.apply(thisArg, [value, key, this]);
    }
  }
  get(key) {
    return __privateGet(this, _values).get(this.hash(key));
  }
  getOrElse(key, orElse) {
    return this.has(key) ? this.get(key) : orElse();
  }
  has(key) {
    return __privateGet(this, _keys).has(this.hash(key));
  }
  set(key, value) {
    const serialized = this.hash(key);
    return __privateGet(this, _keys).set(serialized, key), __privateGet(this, _values).set(serialized, value), __privateGet(this, _entries).set(serialized, [key, value]), this;
  }
  get size() {
    return __privateGet(this, _entries).size;
  }
  entries() {
    return __privateGet(this, _entries).values();
  }
  keys() {
    return __privateGet(this, _keys).values();
  }
  values() {
    return __privateGet(this, _values).values();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
_a = Symbol.toStringTag;
_keys = new WeakMap();
_values = new WeakMap();
_entries = new WeakMap();

// src/omnigraph/map.ts
var _a2;
var OmniPointMap = class extends AbstractMap {
  constructor() {
    super(...arguments);
    __publicField(this, _a2, "OmniPointMap");
  }
  hash(point) {
    return serializePoint(point);
  }
};
_a2 = Symbol.toStringTag;
var _a3;
var OmniVectorMap = class extends AbstractMap {
  constructor() {
    super(...arguments);
    __publicField(this, _a3, "OmniVectorMap");
  }
  hash(vector) {
    return serializeVector(vector);
  }
};
_a3 = Symbol.toStringTag;

// src/omnigraph/builder.ts
var _nodes, _edges, _assertCanAddEdge, assertCanAddEdge_fn;
var _OmniGraphBuilder = class _OmniGraphBuilder {
  constructor() {
    __privateAdd(this, _assertCanAddEdge);
    __privateAdd(this, _nodes, new OmniPointMap());
    __privateAdd(this, _edges, new OmniVectorMap());
  }
  /**
   * Syntactic sugar utility for cloning graphs
   *
   * @param {OmniGraph<TNodeConfig, TEdgeConfig>} graph
   * @returns {OmniGraph<TNodeConfig, TEdgeConfig>}
   */
  static fromGraph(graph) {
    return new _OmniGraphBuilder().addNodes(...graph.contracts).addEdges(...graph.connections);
  }
  //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-
  //  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \
  // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'
  //
  //                      The builder methods
  //
  //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-
  //  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \
  // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'
  addNodes(...nodes) {
    return nodes.forEach((node) => __privateGet(this, _nodes).set(node.point, node)), this;
  }
  addEdges(...edges) {
    return edges.forEach((edge) => {
      __privateMethod(this, _assertCanAddEdge, assertCanAddEdge_fn).call(this, edge);
      __privateGet(this, _edges).set(edge.vector, edge);
    }), this;
  }
  removeNodeAt(point) {
    return (
      // First we remove all edges between this node and any other nodes
      [...this.getEdgesFrom(point)].forEach((edge) => this.removeEdgeAt(edge.vector)), // Only then we remove the node itself
      __privateGet(this, _nodes).delete(point), this
    );
  }
  removeEdgeAt(vector) {
    return __privateGet(this, _edges).delete(vector), this;
  }
  //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-
  //  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \
  // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'
  //
  //                      The accessor methods
  //
  //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-
  //  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \
  // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'
  getNodeAt(point) {
    return __privateGet(this, _nodes).get(point);
  }
  getEdgeAt(vector) {
    return __privateGet(this, _edges).get(vector);
  }
  getEdgesFrom(point) {
    return this.edges.filter(({ vector: { from } }) => arePointsEqual(point, from));
  }
  getEdgesTo(point) {
    return this.edges.filter(({ vector: { to } }) => arePointsEqual(point, to));
  }
  //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-
  //  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \
  // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'
  //
  //                     The config accessors
  //
  //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-
  //  / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \ \ / / \
  // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'
  get nodes() {
    return Array.from(__privateGet(this, _nodes).values());
  }
  get edges() {
    return Array.from(__privateGet(this, _edges).values());
  }
  get graph() {
    return {
      contracts: this.nodes,
      connections: this.edges
    };
  }
};
_nodes = new WeakMap();
_edges = new WeakMap();
_assertCanAddEdge = new WeakSet();
assertCanAddEdge_fn = function(edge) {
  const label = formatOmniVector(edge.vector);
  const from = formatOmniPoint(edge.vector.from);
  assert__default.default(isVectorPossible(edge.vector), `Cannot add edge ${label}: cannot connect the two endpoints`);
  assert__default.default(this.getNodeAt(edge.vector.from), `Cannot add edge ${label}: ${from} is not in the graph`);
};
var OmniGraphBuilder = _OmniGraphBuilder;

// src/transactions/utils.ts
var isNonNullable = (value) => value != null;
var flattenTransactions = (transations) => transations.filter(isNonNullable).flat();
var groupTransactionsByEid = (transactions) => transactions.reduce(
  (transactionsByEid, transaction) => {
    var _a4;
    return transactionsByEid.set(transaction.point.eid, [
      ...(_a4 = transactionsByEid.get(transaction.point.eid)) != null ? _a4 : [],
      transaction
    ]);
  },
  /* @__PURE__ */ new Map()
);
var createConfigureNodes = (createTransactions) => async (graph, createSdk) => flattenTransactions(
  await Promise.all(
    graph.contracts.map(async (node) => {
      const sdk = await createSdk(node.point);
      return await createTransactions(node, sdk, graph, createSdk);
    })
  )
);
var createConfigureEdges = (createTransactions) => async (graph, createSdk) => flattenTransactions(
  await Promise.all(
    graph.connections.map(async (edge) => {
      const sdk = await createSdk(edge.vector.from);
      return await createTransactions(edge, sdk, graph, createSdk);
    })
  )
);
var createConfigureMultiple = (...configurators) => async (graph, createSdk) => {
  const logger = ioDevtools.createModuleLogger("configuration");
  const tasks = configurators.map((configurator) => () => configurator(graph, createSdk));
  const applicative = process.env.LZ_ENABLE_EXPERIMENTAL_PARALLEL_EXECUTION ? (logger.warn(`You are using experimental parallel configuration`), parallel) : sequence;
  return flattenTransactions(await applicative(tasks));
};
var UIntBigIntSchema = zod.z.unknown().transform((value, ctx) => {
  if (typeof value === "bigint") {
    return value;
  }
  try {
    return BigInt(String(value));
  } catch (e) {
    ctx.addIssue({
      code: zod.z.ZodIssueCode.custom,
      message: `Invalid BigInt-like value`
    });
    return zod.z.NEVER;
  }
}).pipe(zod.z.bigint().nonnegative());
var UIntNumberSchema = zod.z.coerce.number().nonnegative().int();
var AddressSchema = zod.z.string();
var EndpointIdSchema = zod.z.nativeEnum(lzDefinitions.EndpointId).pipe(zod.z.number());
var OmniPointSchema = zod.z.object({
  address: AddressSchema,
  eid: EndpointIdSchema
});
var OmniVectorSchema = zod.z.object({
  from: OmniPointSchema,
  to: OmniPointSchema
});
var EmptyOmniNodeSchema = zod.z.object({
  point: OmniPointSchema,
  config: zod.z.unknown().optional()
});
var EmptyOmniEdgeSchema = zod.z.object({
  vector: OmniVectorSchema,
  config: zod.z.unknown().optional()
});
var isOmniPoint = (value) => OmniPointSchema.safeParse(value).success;
var isOmniGraphEmpty = ({ contracts, connections }) => contracts.length === 0 && connections.length === 0;
var createOmniNodeSchema = (configSchema) => EmptyOmniNodeSchema.extend({
  config: configSchema
});
var createOmniEdgeSchema = (configSchema) => EmptyOmniEdgeSchema.extend({
  config: configSchema
});
var createOmniGraphSchema = (nodeSchema, edgeSchema) => zod.z.object({
  contracts: zod.z.array(nodeSchema),
  connections: zod.z.array(edgeSchema)
});

// src/transactions/format.ts
var formatOmniTransaction = (transaction) => ({
  Endpoint: formatEid(transaction.point.eid),
  OmniAddress: transaction.point.address,
  Description: transaction.description,
  Data: transaction.data,
  Value: transaction.value,
  "Gas Limit": transaction.gasLimit
});
var createSignAndSend = (createSigner) => async (transactions, onProgress) => {
  const logger = ioDevtools.createModuleLogger("sign & send");
  const n = transactions.length;
  if (n === 0) {
    return logger.debug(`No transactions to sign, exiting`), [[], [], []];
  }
  logger.debug(`Signing ${n} ${ioDevtools.pluralizeNoun(n, "transaction")}`);
  const transactionGroups = Array.from(groupTransactionsByEid(transactions).entries());
  const successful = [];
  const errors = [];
  const handleSuccess = (result) => {
    successful.push(result);
    onProgress == null ? void 0 : onProgress(result, [...successful]);
  };
  const handleError = (error) => {
    errors.push(error);
  };
  const useBatchedWait = !!process.env.LZ_ENABLE_EXPERIMENTAL_BATCHED_WAIT;
  if (useBatchedWait) {
    logger.warn(`You are using experimental batched transaction waiting`);
  }
  const signerLogic = useBatchedWait ? waitAfterSendingAll : waitBeforeSubmittingNext;
  await Promise.allSettled(
    transactionGroups.map(async ([eid, eidTransactions]) => {
      const eidName = formatEid(eid);
      logger.debug(
        `Signing ${eidTransactions.length} ${ioDevtools.pluralizeNoun(eidTransactions.length, "transaction")} for ${eidName}`
      );
      logger.debug(`Creating signer for ${eidName}`);
      const signer = await createSigner(eid);
      await signerLogic(eid, logger, signer, eidTransactions, handleSuccess, handleError);
      logger.debug(`Successfully signed ${n} ${ioDevtools.pluralizeNoun(n, "transaction")} for ${eidName}`);
    })
  );
  const processed = new Set(successful.map(({ transaction }) => transaction));
  const pending = transactions.filter((transaction) => !processed.has(transaction));
  return [successful, errors, pending];
};
var waitBeforeSubmittingNext = async (eid, logger, signer, transactions, onSuccess, onError) => {
  const eidName = formatEid(eid);
  for (const [index, transaction] of transactions.entries()) {
    const ordinal = ioDevtools.pluralizeOrdinal(index + 1);
    try {
      logger.debug(`Signing ${ordinal} transaction for ${eidName} to ${formatOmniPoint(transaction.point)}`);
      const response = await signer.signAndSend(transaction);
      logger.debug(`Signed ${ordinal} transaction for ${eidName}, got hash ${response.transactionHash}`);
      const receipt = await response.wait();
      logger.debug(`Finished ${ordinal} transaction for ${eidName}`);
      onSuccess({ transaction, receipt });
    } catch (error) {
      logger.debug(`Failed to process ${ordinal} transaction for ${eidName}: ${error}`);
      onError({ transaction, error });
      return;
    }
  }
};
var waitAfterSendingAll = async (eid, logger, signer, transactions, onSuccess, onError) => {
  const eidName = formatEid(eid);
  const responses = [];
  for (const [index, transaction] of transactions.entries()) {
    const ordinal = ioDevtools.pluralizeOrdinal(index + 1);
    try {
      logger.debug(`Signing ${ordinal} transaction for ${eidName} to ${formatOmniPoint(transaction.point)}`);
      const response = await signer.signAndSend(transaction);
      logger.debug(`Signed ${ordinal} transaction for ${eidName}, got hash ${response.transactionHash}`);
      responses.push({ transaction, response });
    } catch (error) {
      logger.debug(`Failed to sign ${ordinal} transaction for ${eidName}: ${error}`);
      onError({ transaction, error });
      break;
    }
  }
  for (const [index, { response, transaction }] of responses.entries()) {
    const ordinal = ioDevtools.pluralizeOrdinal(index + 1);
    try {
      logger.debug(`Waiting for ${ordinal} transaction for ${eidName} to ${formatOmniPoint(transaction.point)}`);
      const receipt = await response.wait();
      logger.debug(`Finished ${ordinal} transaction for ${eidName}`);
      onSuccess({ transaction, receipt });
    } catch (error) {
      logger.debug(`Failed to process ${ordinal} transaction for ${eidName}: ${error}`);
      onError({ transaction, error });
    }
  }
};

exports.AddressSchema = AddressSchema;
exports.AsyncRetriable = AsyncRetriable;
exports.EmptyOmniEdgeSchema = EmptyOmniEdgeSchema;
exports.EmptyOmniNodeSchema = EmptyOmniNodeSchema;
exports.EndpointIdSchema = EndpointIdSchema;
exports.OmniGraphBuilder = OmniGraphBuilder;
exports.OmniPointMap = OmniPointMap;
exports.OmniPointSchema = OmniPointSchema;
exports.OmniVectorMap = OmniVectorMap;
exports.OmniVectorSchema = OmniVectorSchema;
exports.UIntBigIntSchema = UIntBigIntSchema;
exports.UIntNumberSchema = UIntNumberSchema;
exports.areBytes32Equal = areBytes32Equal;
exports.arePointsEqual = arePointsEqual;
exports.areSameEndpoint = areSameEndpoint;
exports.areVectorsEqual = areVectorsEqual;
exports.compareBytes32Ascending = compareBytes32Ascending;
exports.createConfigureEdges = createConfigureEdges;
exports.createConfigureMultiple = createConfigureMultiple;
exports.createConfigureNodes = createConfigureNodes;
exports.createDefaultRetryHandler = createDefaultRetryHandler;
exports.createOmniEdgeSchema = createOmniEdgeSchema;
exports.createOmniGraphSchema = createOmniGraphSchema;
exports.createOmniNodeSchema = createOmniNodeSchema;
exports.createRetryFactory = createRetryFactory;
exports.createSignAndSend = createSignAndSend;
exports.createSimpleRetryStrategy = createSimpleRetryStrategy;
exports.first = first;
exports.firstFactory = firstFactory;
exports.flattenTransactions = flattenTransactions;
exports.formatEid = formatEid;
exports.formatOmniPoint = formatOmniPoint;
exports.formatOmniTransaction = formatOmniTransaction;
exports.formatOmniVector = formatOmniVector;
exports.groupTransactionsByEid = groupTransactionsByEid;
exports.ignoreZero = ignoreZero;
exports.isDeepEqual = isDeepEqual;
exports.isOmniGraphEmpty = isOmniGraphEmpty;
exports.isOmniPoint = isOmniPoint;
exports.isVectorPossible = isVectorPossible;
exports.isZero = isZero;
exports.makeBytes32 = makeBytes32;
exports.mapError = mapError;
exports.parallel = parallel;
exports.sequence = sequence;
exports.serializeDockerComposeSpec = serializeDockerComposeSpec;
exports.serializePoint = serializePoint;
exports.serializeVector = serializeVector;
exports.splitCommaSeparated = splitCommaSeparated;
exports.tapError = tapError;
exports.vectorFromNodes = vectorFromNodes;
exports.withEid = withEid;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map