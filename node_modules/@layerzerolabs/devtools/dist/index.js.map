{"version":3,"sources":["../src/common/assertion.ts","../src/common/bytes.ts","../src/common/promise.ts","../src/common/retry.ts","../src/common/strings.ts","../src/docker/compose.ts","../src/omnigraph/builder.ts","../src/omnigraph/coordinates.ts","../src/omnigraph/format.ts","../src/common/map.ts","../src/omnigraph/map.ts","../src/transactions/utils.ts","../src/omnigraph/config.ts","../src/omnigraph/schema.ts","../src/transactions/format.ts","../src/transactions/signer.ts"],"names":["assert","backOff","_a","EndpointId","createModuleLogger"],"mappings":"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","sourcesContent":["import { deepStrictEqual } from 'assert'\n\n/**\n * Compares two object by value, returning `true` if they match\n *\n * ```\n * const theyMatch = isDeepEqual({ a: 1 }, { a: 1 }) // true\n * const theyDontMatch = isDeepEqual({ a: 1 }, { a: '1' }) // false\n * ```\n *\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport const isDeepEqual = (a: unknown, b: unknown): boolean => {\n    try {\n        return deepStrictEqual(a, b), true\n    } catch {\n        return false\n    }\n}\n","import type { PossiblyBigInt, PossiblyBytes } from '@/types'\nimport { hexZeroPad } from '@ethersproject/bytes'\n\n/**\n * Converts an address into Bytes32 by padding it with zeros.\n *\n * It will return zero bytes if passed `null`, `undefined` or an empty string.\n *\n * @param {PossiblyBytes | null | undefined} address\n * @returns {string}\n */\nexport const makeBytes32 = (address?: PossiblyBytes | null | undefined): PossiblyBytes =>\n    hexZeroPad(address || '0x0', 32)\n\n/**\n * Compares two Bytes32-like values by value (i.e. ignores casing on strings\n * and string length)\n *\n * @param {PossiblyBytes | null | undefined} a\n * @param {PossiblyBytes | null | undefined} b\n * @returns {boolean}\n */\nexport const areBytes32Equal = (a: PossiblyBytes | null | undefined, b: PossiblyBytes | null | undefined): boolean =>\n    BigInt(makeBytes32(a)) === BigInt(makeBytes32(b))\n\n/**\n * Checks whether a value is a zero value.\n *\n * It will return true if passed `null`, `undefined`, empty bytes ('0x') or an empty string.\n *\n * It will throw an error if the value is not a valid numerical value.\n *\n * @param {PossiblyBytes | PossiblyBigInt | null | undefined} value\n * @returns {boolean}\n */\nexport const isZero = (value: PossiblyBytes | PossiblyBigInt | null | undefined): boolean =>\n    value === '0x' || BigInt(value || 0) === BigInt(0)\n\n/**\n * Turns a potentially zero address into undefined\n *\n * @param {PossiblyBytes | PossiblyBigInt | null | undefined} value\n *\n * @returns {string | undefined}\n */\nexport const ignoreZero = <T extends PossiblyBytes | PossiblyBigInt>(value?: T | null | undefined): T | undefined =>\n    isZero(value) ? undefined : value ?? undefined\n\n/**\n * Helper function to be used when sorting of addresses is necessary.\n *\n * This can be used to sort arrays of addresses in ascending manner:\n *\n * ```\n * // The result will be [\"0x000000000000000000636F6e736F6c652e6c6f67\", \"0xEe6cF2E1Bc7645F8439d241ce37820305F2BB3F8\"]\n * [\"0xEe6cF2E1Bc7645F8439d241ce37820305F2BB3F8\", \"0x000000000000000000636F6e736F6c652e6c6f67\"].sort(compareBytes32Ascending)\n * ```\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare}\n *\n * @param {PossiblyBytes} a\n * @param {PossiblyBytes} b\n * @returns {number} `0` when the two are interchangeable, a negative value when `a` comes before `b` and a positive value when `a` comes after `b`\n */\nexport const compareBytes32Ascending = (a: PossiblyBytes, b: PossiblyBytes): number =>\n    Number(BigInt(makeBytes32(a)) - BigInt(makeBytes32(b)))\n","import { Factory } from '@/types'\nimport assert from 'assert'\nimport { backOff } from 'exponential-backoff'\n\n/**\n * Helper type for argumentless factories a.k.a. tasks\n */\ntype Task<T> = Factory<[], T>\n\n/**\n * Executes tasks in sequence, waiting for each one to finish before starting the next one\n *\n * Will resolve with the output of all tasks or reject with the first rejection.\n *\n * @param {Task<T>[]} tasks\n * @returns {Promise<T[]>}\n */\nexport const sequence = async <T>(tasks: Task<T>[]): Promise<T[]> => {\n    const collector: T[] = []\n\n    for (const task of tasks) {\n        collector.push(await task())\n    }\n\n    return collector\n}\n\n/**\n * Executes tasks in parallel\n *\n * Will resolve with the output of all tasks or reject with the any rejection.\n *\n * @param {Task<T>[]} tasks\n * @returns {Promise<T[]>}\n */\nexport const parallel = async <T>(tasks: Task<T>[]): Promise<T[]> => await Promise.all(tasks.map((task) => task()))\n\n/**\n * Maps the errors coming from a task. Errors thrown from the `toError`\n * callback will not be caught.\n *\n * ```\n * const functionThatMightThrow = () => sdk.getSomeAttribute()\n *\n * const result = await mapError(functionThatMightThrow, (error) => new Error(`Error produced: ${error}`))\n * ```\n *\n * @template T\n * @template E\n * @param {(error: unknown) => E} toError Error mapping function\n */\nexport const mapError = async <T, E = unknown>(task: Task<T>, toError: (error: unknown) => E): Promise<Awaited<T>> => {\n    try {\n        return await task()\n    } catch (error: unknown) {\n        throw toError(error)\n    }\n}\n\n/**\n * Intercepts any errors coming from a task. The return value\n * of this call will be the return value of the task\n * and the rejected value will be the original erorr.\n *\n * Any errors or rejections from the `onError` callback will be caught\n * and the original error will be rethrown.\n *\n * ```\n * const functionThatMightThrow = () => sdk.getSomeAttribute()\n *\n * // With custom logging\n * const result = await tapError(functionThatMightThrow, (error) => console.error('Something went wrong:', error))\n *\n * // For lazy people\n * const result = await tapError(functionThatMightThrow, console.error)\n * ```\n *\n * @param {Factory<[error: unknown], void>} onError Synchronous or asynchronous error callback\n */\nexport const tapError = async <T>(task: Task<T>, onError: Factory<[error: unknown], void>): Promise<Awaited<T>> => {\n    try {\n        return await task()\n    } catch (error: unknown) {\n        try {\n            await onError(error)\n        } catch {\n            // Ignore the error from the callback since the original error\n            // is probably more informative\n        }\n\n        throw error\n    }\n}\n\n/**\n * Executes tasks in a sequence until one resolves.\n *\n * Will resolve with the output of the first task that resolves\n * or reject with the last rejection.\n *\n * Will reject immediatelly if no tasks have been passed\n *\n * @param {Task<T>[]} tasks\n * @returns {Promise<T>}\n */\nexport const first = async <T>(tasks: Task<T>[]): Promise<T> => {\n    assert(tasks.length !== 0, `Must have at least one task for first()`)\n\n    let lastError: unknown\n\n    for (const task of tasks) {\n        try {\n            return await task()\n        } catch (error) {\n            lastError = error\n        }\n    }\n\n    throw lastError\n}\n\n/**\n * Helper utility for currying first() - creating a function\n * that behaves like first() but accepts arguments that will be passed to the factory functions\n *\n * @param {Factory<TInput, TOutput>[]} factories\n * @returns {Factory<TInput, TOutput>}\n */\nexport const firstFactory =\n    <TInput extends unknown[], TOutput>(...factories: Factory<TInput, TOutput>[]): Factory<TInput, TOutput> =>\n    async (...input) =>\n        await first(factories.map((factory) => () => factory(...input)))\n\n/**\n * RetryStrategy represents a function that, when passed to `createRetryFactory`,\n * controls the execution of a retried function.\n *\n * It will be executed on every failed attempt and has the ability to modify the\n * input originally passed to the retried function.\n *\n * In its simplest form, it will either return `true` (to retry again) or `false` (stop retrying).\n *\n * In its advanced form, it can use the parameters passed to it to create\n * a new set of arguments passed to the function being retried:\n *\n * ```\n * // As a simple example let's consider a function\n * // whose argument is the amount of money we want to pay for a service\n * const functionThatCanFail = (money: number): Promise<void> => { ... }\n *\n * // We can create a strategy that will keep adding 1 to the amount of money\n * const strategy: RetryStrategy<[money: number]> = (attempt, error, [previousMoney], [originalMoney]) => [previousMoney + 1]\n *\n * // Or we can create a strategy that will adjust the money based on the initial value\n * //\n * // In this made up case it will take the original amount and will add 2 for every failed attempt\n * const strategy: RetryStrategy<[money: number]> = (attempt, error, [previousMoney], [originalMoney]) => [originalMoney + attempt * 2]\n *\n * // Or we can go insane with our logic and can, because without objective morality\n * // everything is permissible, update the amount on every other attempt\n * const strategy: RetryStrategy<[money: number]> = (attempt, error, [previousMoney], [originalMoney]) => attempt % 2 ? [previousMoney + 1] : true\n * ```\n *\n * @param {number} attempt The 0-indexed attempt that the retry function is performing\n * @param {unknown} error The error thrown from the previous execution of the retried function\n * @param {TInput} previousInput The input passed to the previous execution of the retried function\n * @param {TInput} originalInput The input passed to the first execution of the retried function\n */\ntype RetryStrategy<TInput extends unknown[]> = Factory<\n    [attempt: number, error: unknown, previousInput: TInput, originalInput: TInput],\n    TInput | boolean\n>\n\n/**\n * Uses the retry strategy to create a function that can wrap any function with retry logic.\n *\n * ```\n * // As a simple example let's consider a function\n * // whose argument is the amount of money we want to pay for a service\n * const functionThatCanFail = (money: number): Promise<void> => { ... }\n *\n * // By default, it will use a three-times-and-fail retry strategy\n * const retry = createRetryFactory()\n *\n * // It can wrap any function (sync or async) that can throw or reject\n * const retriedFunctionThatCanFail = retry(functionThatCanFail)\n *\n * // The function can then be called just like the original, wrapped function\n * retriedFunctionThatCanFail(1_000_000)\n *\n * // For advanced cases, you can use your own strategy\n * const strategy: RetryStrategy<[money: number]> = () => { ... }\n * const retry = createRetryFactory(strategy)\n * ```\n *\n * @see {@link createSimpleRetryStrategy}\n * @see {@link RetryStrategy}\n *\n * @param {RetryStrategy<TInput>} [strategy] `RetryStrategy` to use. Defaults to a simple strategy that retries three times\n * @returns {<TOutput>(task: Factory<TInput, TOutput>) => Factory<TInput, TOutput>}\n */\nexport const createRetryFactory =\n    <TInput extends unknown[]>(\n        strategy: RetryStrategy<TInput> = createSimpleRetryStrategy(3)\n    ): (<TOutput>(task: Factory<TInput, TOutput>) => Factory<TInput, TOutput>) =>\n    <TOutput>(task: Factory<TInput, TOutput>): Factory<TInput, TOutput> =>\n    async (...input) => {\n        // We'll store the last used input in this variable\n        let currentInput = input\n\n        return backOff(async () => task(...currentInput), {\n            // We'll effectively disable the numOfAttempts for exponential backoff\n            // since we want the behavior to be completely controlled by the strategy\n            numOfAttempts: Number.POSITIVE_INFINITY,\n            // The retry callback is called after an unsuccessful attemp\n            //\n            // It allows us to decide whether we want to keep trying or give up\n            // (we can give up by returning false)\n            //\n            // We'll use this callback to allow the strategy to effectively make changes\n            // to the input, thus allowing it to accommodate for things such as gas price increase\n            // for transactions\n            async retry(error, attempt) {\n                // We will evaluate the strategy first\n                const strategyOutput = await strategy(attempt, error, currentInput, input)\n\n                // The strategy can simply return true/false, in which case we'll not be adjusting the input at all\n                if (typeof strategyOutput === 'boolean') {\n                    return strategyOutput\n                }\n\n                // If we got an input back, we'll adjust it and keep trying\n                return (currentInput = strategyOutput), true\n            },\n        })\n    }\n\n/**\n * Creates a simple `RetryStrategy` that will retry N times.\n *\n * If you want to compose this strategy, you can pass `wrappedStrategy`:\n *\n * ```\n * const myVeryAdvancedStrategy: RetryStrategy<[string, number]> = () => { ... }\n * const myVeryAdvancedStrategyThatWillRetryThreeTimesOnly = createSimpleRetryStrategy(3, myVeryAdvancedStrategy)\n * ```\n *\n * @param {number} numAttempts Must be larger than 0\n * @param {RetryStrategy<TInput>} [wrappedStrategy] Strategy to use if the number of attempts has not been reached yet\n * @returns {RetryStrategy<TInput>}\n */\nexport const createSimpleRetryStrategy = <TInput extends unknown[]>(\n    numAttempts: number,\n    wrappedStrategy?: RetryStrategy<TInput>\n): RetryStrategy<TInput> => {\n    assert(numAttempts > 0, `Number of attempts for a strategy must be larger than 0`)\n\n    return (attempt, error, previousInput, originalInput) => {\n        if (attempt > numAttempts) {\n            return false\n        }\n        if (wrappedStrategy == null) {\n            return true\n        }\n\n        return wrappedStrategy(attempt, error, previousInput, originalInput)\n    }\n}\n","import { createModuleLogger, printJson } from '@layerzerolabs/io-devtools'\nimport assert from 'assert'\nimport { backOff } from 'exponential-backoff'\n\nexport type OnRetry<TInstance, TArgs extends unknown[] = unknown[]> = (\n    attempt: number,\n    numAttempts: number,\n    error: unknown,\n    target: TInstance,\n    method: string,\n    args: TArgs\n) => boolean | void | undefined\n\nexport interface RetriableConfig<TInstance = unknown> {\n    /**\n     * Enable / disable the retry behavior\n     */\n    enabled?: boolean\n    /**\n     * The maximum delay, in milliseconds, between two consecutive attempts.\n     *\n     * @default Infinity\n     */\n    maxDelay?: number\n    /**\n     * Number of times the method call will be retried. The default is 3\n     *\n     * @default 3\n     */\n    numAttempts?: number\n    /**\n     * Callback called on every failed attempt.\n     *\n     * @param {number} attempt 1-indexed number of attempt of executing the method\n     * @param {number} numAttempts Maximum/total number of attempts that will be executed\n     * @param {unknown} error The error that caused the function to be retried\n     * @param {unknown} target The object whose method is being retried\n     * @param {string} method The method name\n     * @param {unknown[]} args The method parameters\n     * @returns {boolean | undefined} This function can stop the retry train by returning false\n     */\n    onRetry?: OnRetry<TInstance>\n}\n\n/**\n * Helper function that creates a default debug logger for the `onRetry`\n * callback of `AsyncRetriable`\n */\nexport const createDefaultRetryHandler = (loggerName: string = 'AsyncRetriable'): OnRetry<unknown> => {\n    const logger = createModuleLogger(loggerName)\n\n    return (attempt, numAttempts, error, target, method, args) => {\n        logger.debug(`Attempt ${attempt}/${numAttempts}: ${method}() with arguments: ${printJson(args)}: ${error}`)\n    }\n}\n\nexport const AsyncRetriable = ({\n    // We'll feature flag this functionality for the time being\n    enabled = !!process.env.LZ_ENABLE_EXPERIMENTAL_RETRY,\n    maxDelay,\n    numAttempts = 3,\n    onRetry = createDefaultRetryHandler(),\n}: RetriableConfig = {}) => {\n    return function AsyncRetriableDecorator<TArgs extends unknown[], TResult>(\n        target: unknown,\n        propertyKey: string,\n        descriptor: TypedPropertyDescriptor<(...args: TArgs) => Promise<TResult>>\n    ) {\n        // If we are disabled, we are disabled\n        if (!enabled) {\n            return descriptor\n        }\n\n        // Grab the original method and ensure that we are decorating a method\n        const originalMethod = descriptor.value\n        assert(\n            typeof originalMethod === 'function',\n            `AsyncRetriable must be applied to an instance method, ${propertyKey} property looks more like ${typeof originalMethod}`\n        )\n\n        // We'll wrap the retry handler from exponential backoff\n        // to make it a bit nicer to use\n        //\n        // - We'll put the attempt as the first argument\n        // - We'll add the decorator target as the last argument\n        //\n        // We'll curry this function so that it can pass the arguments to onRetry\n        const handleRetry =\n            (args: TArgs) =>\n            (error: unknown, attempt: number): boolean =>\n                onRetry?.(attempt, numAttempts, error, target, propertyKey, args) ?? true\n\n        // Create the retried method\n        const retriedMethod = function (this: unknown, ...args: TArgs): Promise<TResult> {\n            // We need to call the original method with the current this context\n            // rather than the target, target can point to a prototype rather than the instance\n            return backOff(() => originalMethod.apply(this, args), {\n                // A typical problem in our case is 429 Too many requests\n                // which would still happen if we didn't introduce a bit of randomness into the delay\n                jitter: 'full',\n                maxDelay,\n                numOfAttempts: numAttempts,\n                retry: handleRetry(args),\n            })\n        }\n\n        // return our new descriptor\n        return (descriptor.value = retriedMethod), descriptor\n    }\n}\n","/**\n * Splits a comma-separated string into individual values\n * and discards any whitespace.\n *\n * @param {string} value\n * @returns {string[]}\n */\nexport const splitCommaSeparated = (value: string): string[] =>\n    value\n        .trim()\n        .split(/\\s*,\\s*/)\n        .filter(Boolean)\n","import { dump } from 'js-yaml'\nimport type { ComposeSpec } from './types'\n\nexport const serializeDockerComposeSpec = (spec: ComposeSpec): string => dump(spec)\n","import assert from 'assert'\nimport { arePointsEqual, isVectorPossible } from './coordinates'\nimport type { OmniEdge, OmniGraph, OmniNode, OmniPoint, OmniVector } from './types'\nimport { formatOmniPoint, formatOmniVector } from './format'\nimport { OmniPointMap, OmniVectorMap } from './map'\n\nexport class OmniGraphBuilder<TNodeConfig = unknown, TEdgeConfig = unknown> {\n    /**\n     * Syntactic sugar utility for cloning graphs\n     *\n     * @param {OmniGraph<TNodeConfig, TEdgeConfig>} graph\n     * @returns {OmniGraph<TNodeConfig, TEdgeConfig>}\n     */\n    static fromGraph<TNodeConfig = unknown, TEdgeConfig = unknown>(\n        graph: OmniGraph<TNodeConfig, TEdgeConfig>\n    ): OmniGraphBuilder<TNodeConfig, TEdgeConfig> {\n        return new OmniGraphBuilder<TNodeConfig, TEdgeConfig>()\n            .addNodes(...graph.contracts)\n            .addEdges(...graph.connections)\n    }\n\n    #nodes: OmniPointMap<OmniNode<TNodeConfig>> = new OmniPointMap()\n\n    #edges: OmniVectorMap<OmniEdge<TEdgeConfig>> = new OmniVectorMap()\n\n    #assertCanAddEdge(edge: OmniEdge<TEdgeConfig>): void {\n        const label = formatOmniVector(edge.vector)\n        const from = formatOmniPoint(edge.vector.from)\n\n        assert(isVectorPossible(edge.vector), `Cannot add edge ${label}: cannot connect the two endpoints`)\n        assert(this.getNodeAt(edge.vector.from), `Cannot add edge ${label}: ${from} is not in the graph`)\n    }\n\n    //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-\n    //  / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\\n    // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'\n    //\n    //                      The builder methods\n    //\n    //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-\n    //  / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\\n    // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'\n\n    addNodes(...nodes: OmniNode<TNodeConfig>[]): this {\n        return nodes.forEach((node) => this.#nodes.set(node.point, node)), this\n    }\n\n    addEdges(...edges: OmniEdge<TEdgeConfig>[]): this {\n        return (\n            edges.forEach((edge) => {\n                // First we make sure we can add this edge\n                this.#assertCanAddEdge(edge)\n\n                // Only then we add it\n                this.#edges.set(edge.vector, edge)\n            }),\n            this\n        )\n    }\n\n    removeNodeAt(point: OmniPoint): this {\n        return (\n            // First we remove all edges between this node and any other nodes\n            [...this.getEdgesFrom(point)].forEach((edge) => this.removeEdgeAt(edge.vector)),\n            // Only then we remove the node itself\n            this.#nodes.delete(point),\n            this\n        )\n    }\n\n    removeEdgeAt(vector: OmniVector): this {\n        return this.#edges.delete(vector), this\n    }\n\n    //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-\n    //  / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\\n    // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'\n    //\n    //                      The accessor methods\n    //\n    //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-\n    //  / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\\n    // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'\n\n    getNodeAt(point: OmniPoint): OmniNode<TNodeConfig> | undefined {\n        return this.#nodes.get(point)\n    }\n\n    getEdgeAt(vector: OmniVector): OmniEdge<TEdgeConfig> | undefined {\n        return this.#edges.get(vector)\n    }\n\n    getEdgesFrom(point: OmniPoint): OmniEdge<TEdgeConfig>[] {\n        return this.edges.filter(({ vector: { from } }) => arePointsEqual(point, from))\n    }\n\n    getEdgesTo(point: OmniPoint): OmniEdge<TEdgeConfig>[] {\n        return this.edges.filter(({ vector: { to } }) => arePointsEqual(point, to))\n    }\n\n    //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-\n    //  / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\\n    // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'\n    //\n    //                     The config accessors\n    //\n    //   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-\n    //  / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\\n    // `-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'\n\n    get nodes(): OmniNode<TNodeConfig>[] {\n        return Array.from(this.#nodes.values())\n    }\n\n    get edges(): OmniEdge<TEdgeConfig>[] {\n        return Array.from(this.#edges.values())\n    }\n\n    get graph(): OmniGraph<TNodeConfig, TEdgeConfig> {\n        return {\n            contracts: this.nodes,\n            connections: this.edges,\n        }\n    }\n}\n","import { EndpointId, endpointIdToStage } from '@layerzerolabs/lz-definitions'\nimport { OmniVector, OmniPoint, OmniNode, WithEid } from './types'\n\n/**\n * Compares two points by value\n *\n * @param a `OmniPoint`\n * @param b `OmniPoint`\n *\n * @returns `true` if the vector point to the same point in omniverse\n */\nexport const arePointsEqual = (a: OmniPoint, b: OmniPoint): boolean => a.address === b.address && a.eid === b.eid\n\n/**\n * Checks if two points are on the same endpoint\n *\n * @param a `OmniPoint`\n * @param b `OmniPoint`\n *\n * @returns `true` if the vector point to the same point in omniverse\n */\nexport const areSameEndpoint = (a: OmniPoint, b: OmniPoint): boolean => a.eid === b.eid\n\n/**\n * Compares two vectors by value\n *\n * @param a `OmniVector`\n * @param b `OmniVector`\n *\n * @returns `true` if the vector point from and to the same point in omniverse\n */\nexport const areVectorsEqual = (a: OmniVector, b: OmniVector): boolean =>\n    arePointsEqual(a.from, b.from) && arePointsEqual(a.to, b.to)\n\n/**\n * Checks that a vector is _possible_ - i.e. connects two endpoints\n * that can be connected in reality.\n *\n * @param vector `OmniVector`\n *\n * @returns `true` if two points of the vector can be connected in reality\n */\nexport const isVectorPossible = ({ from, to }: OmniVector): boolean =>\n    endpointIdToStage(from.eid) === endpointIdToStage(to.eid)\n\n/**\n * Serializes a point. Useful for when points need to be used in Map\n * where we cannot adjust the default behavior of using a reference equality\n *\n * @param point `OmniPoint`\n *\n * @returns `string`\n */\nexport const serializePoint = ({ address, eid }: OmniPoint): string => `${eid}|${address}`\n\n/**\n * Serializes a vector. Useful for when vectors need to be used in Map\n * where we cannot adjust the default behavior of using a reference equality\n *\n * @param point `OmniVector`\n *\n * @returns `string`\n */\nexport const serializeVector = ({ from, to }: OmniVector): string => `${serializePoint(from)} → ${serializePoint(to)}`\n\n/**\n * Helper function to quickly convert a pair of nodes to a vector\n *\n * @param a `OmniNode`\n * @param b `OmniNode`\n * @returns `OmniVector`\n */\nexport const vectorFromNodes = (a: OmniNode, b: OmniNode): OmniVector => ({ from: a.point, to: b.point })\n\n/**\n * Helper function to add an `eid` to arbitrary values, converting them to `WithEid`\n *\n * This is useful to reduce repetition when e.g. creating multiple `OmniPoint` instances on the same network:\n *\n * ```\n * const onMainnet = withEid(EndpointId.ETHEREUM_V2_MAINNET)\n *\n * const onePoint = onMainnet({ address: '0x0' })\n * const anotherPoint = onMainnet({ address: '0x1' })\n * ```\n */\nexport const withEid =\n    (eid: EndpointId) =>\n    <T>(value: T): WithEid<T> => ({ ...value, eid })\n","import { EndpointId } from '@layerzerolabs/lz-definitions'\nimport type { OmniPoint, OmniVector } from './types'\n\nexport const formatEid = (eid: EndpointId): string => EndpointId[eid] ?? `Unknown EndpointId (${eid})`\n\nexport const formatOmniPoint = ({ eid, address }: OmniPoint): string => `[${address} @ ${formatEid(eid)}]`\n\nexport const formatOmniVector = ({ from, to }: OmniVector): string =>\n    `${formatOmniPoint(from)} → ${formatOmniPoint(to)}`\n","export type Hash = string | number | boolean | bigint\n\nexport type HashFunction<T, H extends Hash = Hash> = (value: T) => H\n\n/**\n * Data structure similar to the default ES6 Map\n * with one crucial difference - it requires a hash function\n * which allows it to store values not by reference, but by value\n *\n * The implementation is quite naive as it uses three additional maps\n * to be able to easily implement the ES6 Map interface. This comes at a small\n * storage price which, in our environment, is perfectly negligible.\n *\n * The interface matches the interface of Map with one syntactic sugar added:\n * the getOrElse method that prevents us from having to do null checks on get.\n */\nexport abstract class AbstractMap<K, V> implements Map<K, V> {\n    #keys: Map<Hash, K> = new Map()\n\n    #values: Map<Hash, V> = new Map()\n\n    #entries: Map<Hash, [K, V]> = new Map()\n\n    protected abstract hash(key: K): Hash\n\n    constructor(entries: Iterable<[K, V]> = []) {\n        for (const [key, value] of entries) {\n            this.set(key, value)\n        }\n    }\n\n    clear(): void {\n        this.#keys.clear()\n        this.#values.clear()\n        this.#entries.clear()\n    }\n\n    delete(key: K): boolean {\n        const serialized = this.hash(key)\n\n        return this.#keys.delete(serialized), this.#values.delete(serialized), this.#entries.delete(serialized)\n    }\n\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: unknown): void {\n        for (const [_, [key, value]] of this.#entries) {\n            callbackfn.apply(thisArg, [value, key, this])\n        }\n    }\n\n    get(key: K): V | undefined {\n        return this.#values.get(this.hash(key))\n    }\n\n    getOrElse(key: K, orElse: () => V): V {\n        return this.has(key) ? (this.get(key) as V) : orElse()\n    }\n\n    has(key: K): boolean {\n        return this.#keys.has(this.hash(key))\n    }\n\n    set(key: K, value: V): this {\n        const serialized = this.hash(key)\n\n        return (\n            this.#keys.set(serialized, key),\n            this.#values.set(serialized, value),\n            this.#entries.set(serialized, [key, value]),\n            this\n        )\n    }\n\n    get size(): number {\n        return this.#entries.size\n    }\n\n    entries(): IterableIterator<[K, V]> {\n        return this.#entries.values()\n    }\n\n    keys(): IterableIterator<K> {\n        return this.#keys.values()\n    }\n\n    values(): IterableIterator<V> {\n        return this.#values.values()\n    }\n\n    [Symbol.iterator](): IterableIterator<[K, V]> {\n        return this.entries()\n    }\n\n    [Symbol.toStringTag] = 'HashMap'\n}\n","import { AbstractMap } from '@/common/map'\nimport { serializePoint, serializeVector } from './coordinates'\nimport type { OmniPoint, OmniVector } from './types'\n\nexport class OmniPointMap<V, K extends OmniPoint = OmniPoint> extends AbstractMap<K, V> {\n    [Symbol.toStringTag] = 'OmniPointMap'\n\n    protected override hash(point: K) {\n        return serializePoint(point)\n    }\n}\n\nexport class OmniVectorMap<V, K extends OmniVector = OmniVector> extends AbstractMap<K, V> {\n    [Symbol.toStringTag] = 'OmniVectorMap'\n\n    protected override hash(vector: K) {\n        return serializeVector(vector)\n    }\n}\n","import type { EndpointId } from '@layerzerolabs/lz-definitions'\nimport type { OmniTransaction } from './types'\n\nconst isNonNullable = <T>(value: T | null | undefined): value is T => value != null\n\nexport const flattenTransactions = (\n    transations: (OmniTransaction | OmniTransaction[] | null | undefined)[]\n): OmniTransaction[] => transations.filter(isNonNullable).flat()\n\n/**\n * Groups transactions by their `eid`, preserving the order per group\n *\n * @param {OmniTransaction[]} transactions\n * @returns {Map<EndpointId, OmniTransaction[]>}\n */\nexport const groupTransactionsByEid = (transactions: OmniTransaction[]): Map<EndpointId, OmniTransaction[]> =>\n    transactions.reduce(\n        (transactionsByEid, transaction) =>\n            transactionsByEid.set(transaction.point.eid, [\n                ...(transactionsByEid.get(transaction.point.eid) ?? []),\n                transaction,\n            ]),\n        new Map<EndpointId, OmniTransaction[]>()\n    )\n","import type { Factory } from '@/types'\nimport type { Configurator, IOmniSDK, InferOmniEdge, InferOmniNode, OmniGraph, OmniSDKFactory } from './types'\nimport type { OmniTransaction } from '@/transactions/types'\nimport { flattenTransactions } from '@/transactions/utils'\nimport { createModuleLogger } from '@layerzerolabs/io-devtools'\nimport { parallel, sequence } from '@/common/promise'\n\nexport type CreateTransactionsFromOmniNodes<TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK> = Factory<\n    [InferOmniNode<TOmniGraph>, TOmniSDK, TOmniGraph, OmniSDKFactory<TOmniSDK>],\n    OmniTransaction[] | OmniTransaction | null | undefined\n>\n\nexport type CreateTransactionsFromOmniEdges<TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK> = Factory<\n    [InferOmniEdge<TOmniGraph>, TOmniSDK, TOmniGraph, OmniSDKFactory<TOmniSDK>],\n    OmniTransaction[] | OmniTransaction | null | undefined\n>\n\n/**\n * Function that takes care of the boilerplate for node configuration functions.\n *\n * It will create an SDK for every node in the graph, then call `createTransactions`\n * with the node itself, the created SDK, the whole graph and the SDK factory.\n *\n * ```\n * const configureSomething = createConfigureNodes(async ({ config }: OmniNode<{ something: string }>, sdk) => {\n *   const something = await sdk.getSomething()\n *   if (something !== config.something) return []\n *\n *   return sdk.setSomething(config.something)\n * })\n * ```\n *\n * @template TOmniGraph\n * @template TOmniSDK\n * @param {CreateTransactionsFromOmniNodes<TOmniGraph, TOmniSDK>} createTransactions\n * @returns {Configurator<TOmniGraph, TOmniSDK>}\n */\nexport const createConfigureNodes =\n    <TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK>(\n        createTransactions: CreateTransactionsFromOmniNodes<TOmniGraph, TOmniSDK>\n    ): Configurator<TOmniGraph, TOmniSDK> =>\n    async (graph, createSdk) =>\n        flattenTransactions(\n            await Promise.all(\n                graph.contracts.map(async (node) => {\n                    const sdk = await createSdk(node.point)\n\n                    return await createTransactions(node, sdk, graph, createSdk)\n                })\n            )\n        )\n\n/**\n * Function that takes care of the boilerplate for edge configuration functions.\n *\n * It will create an SDK for every edge (using the `from` field) in the graph, then call `createTransactions`\n * with the edge itself, the created SDK, the whole graph and the SDK factory.\n *\n * ```\n * const configureSomething = createConfigureEdges(async ({ config, vector: { to } }: OmniEdge<{ something: string }>, sdk) => {\n *   const something = await sdk.getSomethingFor(to.eid)\n *   if (something !== config.something) return []\n *\n *   return sdk.setSomething(to.eid, config.something)\n * })\n * ```\n *\n * @template TOmniGraph\n * @template TOmniSDK\n * @param {CreateTransactionsFromOmniEdges<TOmniGraph, TOmniSDK>} createTransactions\n * @returns {Configurator<TOmniGraph, TOmniSDK>}\n */\nexport const createConfigureEdges =\n    <TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK>(\n        createTransactions: CreateTransactionsFromOmniEdges<TOmniGraph, TOmniSDK>\n    ): Configurator<TOmniGraph, TOmniSDK> =>\n    async (graph, createSdk) =>\n        flattenTransactions(\n            await Promise.all(\n                graph.connections.map(async (edge) => {\n                    const sdk = await createSdk(edge.vector.from)\n\n                    return await createTransactions(edge, sdk, graph, createSdk)\n                })\n            )\n        )\n\n/**\n * Helper function that takes multiple configurators and executes them\n * (the execution is parallel or serial based on the LZ_ENABLE_EXPERIMENTAL_PARALLEL_EXECUTION\n * feature flag at the moment)\n *\n * ```\n * const configureOApp = createConfigureMultiple(\n *   configureOAppPeers\n *   configureSendLibraries\n *   configureReceiveLibraries\n *   configureReceiveLibraryTimeouts\n *   configureSendConfig\n *   configureReceiveConfig\n *   configureEnforcedOptions\n *   configureOAppDelegates\n * )\n * ```\n *\n * @param {...Configurator<TOmniGraph, TOmniSDK>} configurators An array of configuration functions\n * @returns {Configurator<TOmniGraph, TOmniSDK>}\n */\nexport const createConfigureMultiple =\n    <TOmniGraph extends OmniGraph = OmniGraph, TOmniSDK = IOmniSDK>(\n        ...configurators: Configurator<TOmniGraph, TOmniSDK>[]\n    ): Configurator<TOmniGraph, TOmniSDK> =>\n    async (graph, createSdk) => {\n        const logger = createModuleLogger('configuration')\n        const tasks = configurators.map((configurator) => () => configurator(graph, createSdk))\n\n        // For now we keep the parallel execution as an opt-in feature flag\n        // before we have a retry logic fully in place for the SDKs\n        //\n        // This is to avoid 429 too many requests errors from the RPCs\n        const applicative = process.env.LZ_ENABLE_EXPERIMENTAL_PARALLEL_EXECUTION\n            ? (logger.warn(`You are using experimental parallel configuration`), parallel)\n            : sequence\n\n        return flattenTransactions(await applicative(tasks))\n    }\n","import { EndpointId } from '@layerzerolabs/lz-definitions'\nimport { z } from 'zod'\nimport type { OmniPoint, OmniNode, OmniVector, OmniEdge, OmniGraph } from './types'\n\n/**\n * Schema for parsing strings, bigints and numbers to uint backed by bigint\n *\n * It does not use z.coerce in order to avoid errors coming from BigInt() constructor\n */\nexport const UIntBigIntSchema = z\n    .unknown()\n    .transform((value, ctx): bigint => {\n        if (typeof value === 'bigint') {\n            return value\n        }\n\n        try {\n            return BigInt(String(value))\n        } catch {\n            ctx.addIssue({\n                code: z.ZodIssueCode.custom,\n                message: `Invalid BigInt-like value`,\n            })\n\n            return z.NEVER\n        }\n    })\n    .pipe(z.bigint().nonnegative())\n\nexport const UIntNumberSchema = z.coerce.number().nonnegative().int()\n\nexport const AddressSchema = z.string()\n\nexport const EndpointIdSchema: z.ZodSchema<EndpointId, z.ZodTypeDef, string | number> = z\n    .nativeEnum(EndpointId)\n    .pipe(z.number())\n\nexport const OmniPointSchema: z.ZodSchema<OmniPoint, z.ZodTypeDef, unknown> = z.object({\n    address: AddressSchema,\n    eid: EndpointIdSchema,\n})\n\nexport const OmniVectorSchema: z.ZodSchema<OmniVector, z.ZodTypeDef, unknown> = z.object({\n    from: OmniPointSchema,\n    to: OmniPointSchema,\n})\n\nexport const EmptyOmniNodeSchema = z.object({\n    point: OmniPointSchema,\n    config: z.unknown().optional(),\n})\n\nexport const EmptyOmniEdgeSchema = z.object({\n    vector: OmniVectorSchema,\n    config: z.unknown().optional(),\n})\n\n/**\n * Helper assertion utility for `OmniPoint` instances\n *\n * @param {unknown} value\n * @returns {boolean} `true` if the value is an `OmniPoint`, `false` otherwise\n */\nexport const isOmniPoint = (value: unknown): value is OmniPoint => OmniPointSchema.safeParse(value).success\n\n/**\n * Helper assertion utility that checks whether an `OmniGraph`\n * has at least any contracts or connections defined\n *\n * @param {OmniGraph} graph\n * @returns {boolean}\n */\nexport const isOmniGraphEmpty = ({ contracts, connections }: OmniGraph): boolean =>\n    contracts.length === 0 && connections.length === 0\n\n/**\n * Factory for OmniNode schemas\n *\n * @param configSchema Schema of the config contained in the node\n *\n * @returns `z.ZodSchema<OmniNode<TConfig>>` schema for a node with the particular config type\n */\nexport const createOmniNodeSchema = <TConfig = unknown>(\n    configSchema: z.ZodSchema<TConfig, z.ZodTypeDef, unknown>\n): z.ZodSchema<OmniNode<TConfig>, z.ZodTypeDef, unknown> =>\n    EmptyOmniNodeSchema.extend({\n        config: configSchema,\n    }) as z.ZodSchema<OmniNode<TConfig>, z.ZodTypeDef>\n\n/**\n * Factory for OmniEdge schemas\n *\n * @param {z.ZodSchema<TConfig>} configSchema Schema of the config contained in the edge\n *\n * @returns {z.ZodSchema<OmniEdge<TConfig>>} Schema for an edge with the particular config type\n */\nexport const createOmniEdgeSchema = <TConfig = unknown>(\n    configSchema: z.ZodSchema<TConfig, z.ZodTypeDef, unknown>\n): z.ZodSchema<OmniEdge<TConfig>, z.ZodTypeDef, unknown> =>\n    EmptyOmniEdgeSchema.extend({\n        config: configSchema,\n    }) as z.ZodSchema<OmniEdge<TConfig>, z.ZodTypeDef>\n\n/**\n * Factory for OmniGraph schemas\n *\n * @param {z.ZodSchema<OmniNode<TNodeConfig>, z.ZodTypeDef, unknown>} nodeSchema\n * @param {z.ZodSchema<OmniEdge<TEdgeConfig>, z.ZodTypeDef, unknown>} edgeSchema\n *\n * @returns {z.ZodSchema<OmniGraph<TNodeConfig, TEdgeConfig>, z.ZodTypeDef, unknown>}\n */\nexport const createOmniGraphSchema = <TNodeConfig = unknown, TEdgeConfig = unknown>(\n    nodeSchema: z.ZodSchema<OmniNode<TNodeConfig>, z.ZodTypeDef, unknown>,\n    edgeSchema: z.ZodSchema<OmniEdge<TEdgeConfig>, z.ZodTypeDef, unknown>\n): z.ZodSchema<OmniGraph<TNodeConfig, TEdgeConfig>, z.ZodTypeDef, unknown> =>\n    z.object({\n        contracts: z.array(nodeSchema),\n        connections: z.array(edgeSchema),\n    })\n","import { OmniTransaction } from './types'\nimport { formatEid } from '@/omnigraph/format'\n\nexport const formatOmniTransaction = (\n    transaction: OmniTransaction\n): Record<string, string | number | bigint | undefined> => ({\n    Endpoint: formatEid(transaction.point.eid),\n    OmniAddress: transaction.point.address,\n    Description: transaction.description,\n    Data: transaction.data,\n    Value: transaction.value,\n    'Gas Limit': transaction.gasLimit,\n})\n","import { Logger, createModuleLogger, pluralizeNoun, pluralizeOrdinal } from '@layerzerolabs/io-devtools'\nimport type {\n    OmniSigner,\n    OmniSignerFactory,\n    OmniTransaction,\n    OmniTransactionWithError,\n    OmniTransactionWithReceipt,\n    OmniTransactionWithResponse,\n} from './types'\nimport { formatEid, formatOmniPoint } from '@/omnigraph/format'\nimport { groupTransactionsByEid } from './utils'\nimport { EndpointId } from '@layerzerolabs/lz-definitions'\n\nexport type SignAndSendResult = [\n    // All the successful transactions\n    successful: OmniTransactionWithReceipt[],\n    // The failed transactions along with the errors\n    errors: OmniTransactionWithError[],\n    // All the transactions that have not been executed (including the failed ones)\n    pending: OmniTransaction[],\n]\n\nexport type OnSignAndSendProgress = (\n    result: OmniTransactionWithReceipt,\n    results: OmniTransactionWithReceipt[]\n) => unknown\n\nexport type SignAndSend = (\n    transactions: OmniTransaction[],\n    onProgress?: OnSignAndSendProgress\n) => Promise<SignAndSendResult>\n\n/**\n * Creates a sign & send utility for a list of transaction\n * with a help of `OmniSignerFactory`\n *\n * @param {OmniSignerFactory} createSigner\n */\nexport const createSignAndSend =\n    (createSigner: OmniSignerFactory): SignAndSend =>\n    async (transactions, onProgress): Promise<SignAndSendResult> => {\n        const logger = createModuleLogger('sign & send')\n\n        // Put it here so that we don't need to type like seven toilet rolls of variable names\n        const n = transactions.length\n\n        // Just exit when there is nothing to sign\n        if (n === 0) {\n            return logger.debug(`No transactions to sign, exiting`), [[], [], []]\n        }\n\n        // Tell the user how many we are signing\n        logger.debug(`Signing ${n} ${pluralizeNoun(n, 'transaction')}`)\n\n        const transactionGroups = Array.from(groupTransactionsByEid(transactions).entries())\n\n        // We'll gather the state of the signing here\n        const successful: OmniTransactionWithReceipt[] = []\n        const errors: OmniTransactionWithError[] = []\n\n        const handleSuccess = (result: OmniTransactionWithReceipt) => {\n            // Here we want to update the global state of the signing\n            successful.push(result)\n\n            // We'll create a clone of the successful array so that the consumers can't mutate it\n            onProgress?.(result, [...successful])\n        }\n\n        const handleError = (error: OmniTransactionWithError) => {\n            // Update the error state\n            errors.push(error)\n        }\n\n        // Based on this feature flag we'll either wait for every transaction before sending the next one\n        // or we submit them all and wait at the very end\n        const useBatchedWait = !!process.env.LZ_ENABLE_EXPERIMENTAL_BATCHED_WAIT\n        if (useBatchedWait) {\n            logger.warn(`You are using experimental batched transaction waiting`)\n        }\n\n        const signerLogic: TransactionSignerLogic = useBatchedWait ? waitAfterSendingAll : waitBeforeSubmittingNext\n\n        await Promise.allSettled(\n            transactionGroups.map(async ([eid, eidTransactions]): Promise<void> => {\n                const eidName = formatEid(eid)\n\n                logger.debug(\n                    `Signing ${eidTransactions.length} ${pluralizeNoun(eidTransactions.length, 'transaction')} for ${eidName}`\n                )\n\n                logger.debug(`Creating signer for ${eidName}`)\n                const signer = await createSigner(eid)\n\n                await signerLogic(eid, logger, signer, eidTransactions, handleSuccess, handleError)\n\n                // Tell the inquisitive user what a good job we did\n                logger.debug(`Successfully signed ${n} ${pluralizeNoun(n, 'transaction')} for ${eidName}`)\n            })\n        )\n\n        // Now we create a list of the transactions that have not been touched\n        //\n        // We do this by taking all the transactions, then filtering out those\n        // that don't have a result associated with them\n        //\n        // This functionality relies on reference equality of the transactions objects\n        // so it's important that we don't mess with those and push the transaction\n        // objects directly to the `successful` and `errors` arrays, without any rest spreading or whatnot\n        const processed = new Set<OmniTransaction>(successful.map(({ transaction }) => transaction))\n        const pending = transactions.filter((transaction) => !processed.has(transaction))\n\n        return [successful, errors, pending]\n    }\n\ntype TransactionSignerLogic = (\n    eid: EndpointId,\n    logger: Logger,\n    signer: OmniSigner,\n    transactions: OmniTransaction[],\n    onSuccess: (resut: OmniTransactionWithReceipt) => void,\n    onError: (error: OmniTransactionWithError) => void\n) => Promise<void>\n\n/**\n * This transaction submitting logic will wait for every single transaction\n * before submitting the next one. This is the default logic, it results in transactions\n * being submitted in separate blocks.\n *\n * This is a safer yet slower strategy since:\n *\n * - A revert will only incur costs on the reverted transaction.\n * - A revert will stop the submitting, especially important if the transactions later on in the list\n *   rely heavily on the earlier ones without this reliance being coded into the contract\n */\nconst waitBeforeSubmittingNext: TransactionSignerLogic = async (\n    eid,\n    logger,\n    signer,\n    transactions,\n    onSuccess,\n    onError\n) => {\n    const eidName = formatEid(eid)\n\n    for (const [index, transaction] of transactions.entries()) {\n        // We want to refer to this transaction by index so we create an ordinal for it (1st, 2nd etc)\n        const ordinal = pluralizeOrdinal(index + 1)\n\n        try {\n            logger.debug(`Signing ${ordinal} transaction for ${eidName} to ${formatOmniPoint(transaction.point)}`)\n            const response = await signer.signAndSend(transaction)\n\n            logger.debug(`Signed ${ordinal} transaction for ${eidName}, got hash ${response.transactionHash}`)\n\n            const receipt = await response.wait()\n            logger.debug(`Finished ${ordinal} transaction for ${eidName}`)\n\n            onSuccess({ transaction, receipt })\n        } catch (error) {\n            logger.debug(`Failed to process ${ordinal} transaction for ${eidName}: ${error}`)\n\n            // Update the error state\n            onError({ transaction, error })\n\n            // We want to stop the moment we hit an error\n            return\n        }\n    }\n}\n\n/**\n * This transaction submitting logic will submit all transactions first,\n * then wait for them once they all have been submitted. This is an experimental logic, it results in transactions\n * being submitted in potentially the same block.\n *\n * This is a more adventuurous yet faster strategy since:\n *\n * - A revert might incur costs on not only the reverted transaction but on the subsequent transactions as well\n * - A revert will not stop the submitting, especially important if the transactions later on in the list\n *   rely heavily on the earlier ones without this reliance being coded into the contract\n */\nconst waitAfterSendingAll: TransactionSignerLogic = async (eid, logger, signer, transactions, onSuccess, onError) => {\n    const eidName = formatEid(eid)\n\n    const responses: OmniTransactionWithResponse[] = []\n\n    for (const [index, transaction] of transactions.entries()) {\n        // We want to refer to this transaction by index so we create an ordinal for it (1st, 2nd etc)\n        const ordinal = pluralizeOrdinal(index + 1)\n\n        try {\n            logger.debug(`Signing ${ordinal} transaction for ${eidName} to ${formatOmniPoint(transaction.point)}`)\n            const response = await signer.signAndSend(transaction)\n\n            logger.debug(`Signed ${ordinal} transaction for ${eidName}, got hash ${response.transactionHash}`)\n\n            responses.push({ transaction, response })\n        } catch (error) {\n            logger.debug(`Failed to sign ${ordinal} transaction for ${eidName}: ${error}`)\n\n            // Update the error state\n            onError({ transaction, error })\n\n            // Stop submitting any other transactions\n            break\n        }\n    }\n\n    for (const [index, { response, transaction }] of responses.entries()) {\n        // We want to refer to this transaction by index so we create an ordinal for it (1st, 2nd etc)\n        const ordinal = pluralizeOrdinal(index + 1)\n\n        try {\n            logger.debug(`Waiting for ${ordinal} transaction for ${eidName} to ${formatOmniPoint(transaction.point)}`)\n\n            const receipt = await response.wait()\n            logger.debug(`Finished ${ordinal} transaction for ${eidName}`)\n\n            onSuccess({ transaction, receipt })\n        } catch (error) {\n            logger.debug(`Failed to process ${ordinal} transaction for ${eidName}: ${error}`)\n\n            // Update the error state\n            onError({ transaction, error })\n        }\n    }\n}\n"]}